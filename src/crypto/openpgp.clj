; A Bouncy Castle based OpenPGP library for Clojure.
; https://github.com/MailTube/crypto.openpgp
; This is free and unencumbered software released into the public domain.
(ns crypto.openpgp
  (:import
    [java.util Date]
    [java.io FilterOutputStream FilterInputStream]
    [java.security SecureRandom]
    [org.apache.commons.math3.distribution BinomialDistribution]
    [org.apache.commons.math3.stat.inference ChiSquareTest]
    [org.apache.commons.math3.util FastMath]
    [org.bouncycastle.crypto.params 
     RSAKeyGenerationParameters DSAKeyGenerationParameters 
     ElGamalKeyGenerationParameters DSAParameterGenerationParameters]
    [org.bouncycastle.crypto.generators
     RSAKeyPairGenerator DSAParametersGenerator DSAKeyPairGenerator
     ElGamalParametersGenerator ElGamalKeyPairGenerator]
    [org.bouncycastle.crypto.digests SHA256Digest]
    [org.bouncycastle.openpgp
     PGPLiteralDataGenerator PGPCompressedDataGenerator 
     PGPEncryptedDataGenerator PGPLiteralData PGPCompressedData 
     PGPPBEEncryptedData PGPObjectFactory PGPMarker PGPUtil
     PGPEncryptedDataList PGPKeyRingGenerator PGPSignature 
     PGPSignatureSubpacketGenerator PGPSignatureGenerator
     PGPSecretKey PGPSecretKeyRing PGPPublicKey PGPPublicKeyRing]
    [org.bouncycastle.openpgp.operator.bc 
     BcPGPDataEncryptorBuilder BcPBEKeyEncryptionMethodGenerator
     BcPBEDataDecryptorFactory BcPGPDigestCalculatorProvider
     BcPGPKeyPair BcPBESecretKeyEncryptorBuilder BcPGPContentSignerBuilder
     BcPBESecretKeyDecryptorBuilder]
    [org.bouncycastle.bcpg 
     CompressionAlgorithmTags SymmetricKeyAlgorithmTags
     ArmoredOutputStream PublicKeyAlgorithmTags HashAlgorithmTags]
    [org.bouncycastle.bcpg.sig 
     KeyFlags Features RevocationReasonTags]))

;-------------------------------------------------------------------------------

(defn library-version [] "0.1.0")

(defmacro check
  ([x]
    `(when-not ~x
       (throw (new AssertionError (str "Check failed: " (pr-str '~x))))))
  ([x message]
    `(when-not ~x
       (throw (new AssertionError (str "Check failed: " ~message "\n" (pr-str '~x)))))))

;-------------------------------------------------------------------------------

(defn- nr-bitcount [input]
  (let [num (biginteger input)]
    (check (>= (.signum num) 0)) 
    (.bitCount num)))

(defn- nr-expected [n runs]
  (let [d (new org.apache.commons.math3.distribution.BinomialDistribution n 0.5)]
    (vec (map #(* runs (.probability d %)) (range (inc n))))))

(defn- nr-observed [input bitsize runs]
  (loop [v (transient (vec (repeat (inc bitsize) 0))), r0 (biginteger (input)), i 0] 
    (if (< i runs)
      (let [r1 (biginteger (input)), bc (nr-bitcount (.xor r0 r1))]
        (recur (assoc! v bc (inc (v bc))) r1 (inc i)))
      (persistent! v))))

(defn- nr-run [input bitsize runs alpha]
  (let 
    [observed (nr-observed input bitsize runs), 
     expected (nr-expected bitsize runs),
     t (new org.apache.commons.math3.stat.inference.ChiSquareTest)]
    (.chiSquareTest t (double-array expected) (long-array observed) alpha)))

; A rough and very simple test to estimate whether a random number generator is compromised. Implemented as a SAC-test (Castro, Sierra, Seznec, Izquierdo, Ribagorda, 2005). Parameters: 'random' is an object of type java.util.Random; 'bitsize' is the size in bits of every number to be generated by 'random' for evaluation; the total amount of generated numbers will be 'runs'+1; 'alpha' is a threshold for p-value. The function calculates p-value and returns true when p-value < 'alpha'.
(defn not-random [random bitsize runs alpha]
  (nr-run #(new java.math.BigInteger bitsize random) bitsize runs alpha))

;-------------------------------------------------------------------------------

(defn- gp-b62 [d]
  ([\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 
    \a \b \c \d \e \f \g \h \i \j \k \l \m \n \o \p \q \r \s \t \u \v \w \x \y \z 
    \A \B \C \D \E \F \G \H \I \J \K \L \M \N \O \P \Q \R \S \T \U \V \W \X \Y \Z]
    d))

; Generates a secure password and returns it in the form of a vector of random Character's. Parameter 'entropy' specifies the password desired strength in bits. Optional named parameters: 'random' is an object of type java.util.Random, defaults to a new java.security.SecureRandom; 'radix' is the size of a password alphabet, defaults to 62; 'mapping' is a function that maps a number into a corresponding alphabet's Character, default function maps into Base62.
(defn gen-password [entropy & 
                    {:keys [random radix mapping]
                     :or {random (new java.security.SecureRandom),
                          radix 62, mapping gp-b62}}]
  (let [num (new BigInteger entropy random),
        len (FastMath/round 
              (FastMath/ceil (* entropy (FastMath/log radix 2.0)))),
        gen (fn [[q _]] (.divideAndRemainder q (biginteger radix)))]
    (shuffle 
      (map mapping (take len (rest (map second (iterate gen [num 0]))))))))

;-------------------------------------------------------------------------------

(defn default-partial [] 1048576)

(definterface ^:private ChainedClose)

(defn- chained-close [stream chained]
  (proxy [FilterOutputStream ChainedClose] [stream]
    (close [] 
      (.close stream) 
      (when (instance? ChainedClose chained)
        (.close chained)))))

(defn- skat-from-str [str]
  (case str
    "3DES" SymmetricKeyAlgorithmTags/TRIPLE_DES,
    "CAST5" SymmetricKeyAlgorithmTags/CAST5, 
    "BLOWFISH" SymmetricKeyAlgorithmTags/BLOWFISH, 
    "AES" SymmetricKeyAlgorithmTags/AES_128,
    "AES192" SymmetricKeyAlgorithmTags/AES_192, 
    "AES256" SymmetricKeyAlgorithmTags/AES_256,
    "TWOFISH" SymmetricKeyAlgorithmTags/TWOFISH,
    nil SymmetricKeyAlgorithmTags/NULL))

(defn- write-armored [os]
  (let [aos (new ArmoredOutputStream os)]
    (chained-close aos os)))

(defn- write-pbe-encrypted [os pw & 
                           {:keys [partial cipher integrity]
                            :or {partial (default-partial),
                                 cipher "AES256",
                                 integrity true}}]
  (check (sequential? pw))
  (let [deb (new BcPGPDataEncryptorBuilder (skat-from-str cipher))]
    (.setWithIntegrityPacket deb integrity)
    (let [edg (new PGPEncryptedDataGenerator deb),
          emg (new BcPBEKeyEncryptionMethodGenerator (char-array pw)),
          buffer (byte-array partial)]
      (.addMethod edg emg)
      (chained-close (.open edg os buffer) os))))

(defn- write-compressed [os &
                        {:keys [partial]
                         :or {partial (default-partial)}}]
  (let [cdg (new PGPCompressedDataGenerator CompressionAlgorithmTags/ZIP),
        buffer (byte-array partial)]
    (chained-close (.open cdg os buffer) os)))

(defn- write-literal [os &
                     {:keys [partial]
                      :or {partial (default-partial)}}]
  (let [ldg (new PGPLiteralDataGenerator),
        date (new Date 0),
        buffer (byte-array partial)]
    (chained-close (.open ldg os PGPLiteralData/BINARY "" date buffer) os)))

; Creates a password based encryptor. Returns a java.io.OutputStream object for the caller application to write plaintext into. Parameters: 'output' is a java.io.OutputStream object that will receive ciphertext; 'password' is a sequence of Character's. Optional named parameters: 'enarmor' specifies whether to produce armored textual ciphertext, defaults to false; if 'compress' is false then no compression of plaintext will be done before encryption, default is to compress data; encryption will be performed with a 'cipher' algorithm, defaults to "AES256"; if 'integrity' is false then integrity packet that protects data from modification will not be written, default is to write this packet; 'partial' specifies the size in bytes of partial data packets to use during plaintext processing, compression and encryption phases, defaults to 1Mb. The returned stream must be closed if and only if all desired plaintext data was written into it successfully. Closing the returned stream does not close 'output'.
(defn pbe-encryptor [output password &
                     {:keys [enarmor compress] 
                      :or {enarmor false,
                           compress true} 
                      :as conf}]
  (let [forward (flatten (seq conf)),
        arm (if enarmor (write-armored output) output), 
        enc (apply (partial write-pbe-encrypted arm password) forward),
        com (if compress (apply (partial write-compressed enc) forward) enc),
        lit (apply (partial write-literal com) forward)]
    lit))

;-------------------------------------------------------------------------------

(defn- dearmor [is]
  (PGPUtil/getDecoderStream is))

(defn- object-factory [is]
  (let [of (new PGPObjectFactory is)]
    (filter #(not (instance? PGPMarker %)) (repeatedly #(.nextObject of)))))

(defn- parse-pbe-encrypted [of pw]
  (check (sequential? pw))
  (let [edl (cast PGPEncryptedDataList (first of)),
        ed (first (filter 
                    (partial instance? PGPPBEEncryptedData) 
                    (iterator-seq (.getEncryptedDataObjects edl))))]
    (check ed)
    (let [ddf (new BcPBEDataDecryptorFactory (char-array pw) 
                (new BcPGPDigestCalculatorProvider))]
      [(object-factory (.getDataStream ed ddf)) ed])))

(defn- parse-compressed [of]
  (let [ld (first of)]
    (if (not (instance? PGPCompressedData ld))
      of (object-factory (.getDataStream ld)))))

(defn- parse-literal [of]
  (let [ld (first (filter #(instance? PGPLiteralData %) of))]
    (check ld)
    (.getInputStream ld)))

; Creates a password based decryptor. Returns a java.io.InputStream object for the caller application to read plaintext from. Parameters: 'input' is a java.io.InputStream object that will be used as a source of ciphertext; 'password' is a sequence of Character's. Closing the returned stream possibly drains all unread data, performs an integrity check and does not close 'input'.
(defn pbe-decryptor [input password]
  (let [[of ed] (parse-pbe-encrypted
                  (object-factory (dearmor input)) password),
        stream (parse-literal (parse-compressed of))]
    (proxy [FilterInputStream] [stream]
      (close []
        (check (.verify ed))))))

;-------------------------------------------------------------------------------

(defn- prime-certainty [] 80)

(defn- pkat-from-str [str]
  (case str
    "RSA-S" PublicKeyAlgorithmTags/RSA_SIGN,
    "RSA-E" PublicKeyAlgorithmTags/RSA_ENCRYPT,
    "DSA" PublicKeyAlgorithmTags/DSA,
    "ELG-E" PublicKeyAlgorithmTags/ELGAMAL_ENCRYPT))

(defn- gen-rsa-kp [random strength]
  (let [kgp (new RSAKeyGenerationParameters 
              (biginteger 65537) random strength (prime-certainty)),
        kpg (new RSAKeyPairGenerator)]
    (.init kpg kgp) 
    (.generateKeyPair kpg)))

(defn- gen-dsa-kp [random l-strength]
  (let [n-strength (if (> l-strength 1024) 256 160),
        pgp (new DSAParameterGenerationParameters 
              l-strength n-strength (prime-certainty) random 
              DSAParameterGenerationParameters/DIGITAL_SIGNATURE_USAGE),
        pg (new DSAParametersGenerator (new SHA256Digest))]
    (.init pg pgp)
    (let [p (.generateParameters pg),
          kgp (new DSAKeyGenerationParameters random p),
          kpg (new DSAKeyPairGenerator)]
      (.init kpg kgp) 
      (.generateKeyPair kpg))))

(defn- gen-elg-kp [random strength]
  (let [pg (new ElGamalParametersGenerator)]
    (.init pg strength (prime-certainty) random)
    (let [p (.generateParameters pg),
          kgp (new ElGamalKeyGenerationParameters random p),
          kpg (new ElGamalKeyPairGenerator)]
      (.init kpg kgp) 
      (.generateKeyPair kpg))))

(defn- gen-ssv [date issuer & {:keys [expire flags mdc revocation]}]
  (let [ssg (new PGPSignatureSubpacketGenerator)]
    (.setSignatureCreationTime ssg false date)
    (.setIssuerKeyID ssg false issuer)
    (when expire (when (> expire 0)
      (.setKeyExpirationTime ssg false expire)))
    (when flags 
      (.setKeyFlags ssg false 
        (case flags
          :encrypt (bit-or KeyFlags/ENCRYPT_COMMS KeyFlags/ENCRYPT_STORAGE)
          :sign (bit-or KeyFlags/SIGN_DATA KeyFlags/CERTIFY_OTHER))))
    (when mdc
      (.setFeature ssg false Features/FEATURE_MODIFICATION_DETECTION))
    (when revocation
      (.setRevocationReason ssg false RevocationReasonTags/NO_REASON ""))
    (.generate ssg)))

(defn- gen-ssv-std [date issuer expire]
  (gen-ssv date issuer, :expire expire, :mdc true, :flags :sign))

(defn- key-collide? [key1 key2]
  (= (.getKeyID key1) (.getKeyID key2)))

(defn- key-pair? [public secret]
  (and (instance? PGPPublicKey public) (instance? PGPSecretKey secret)
    (key-collide? public secret)))

(defn- key-signing? [key]
  (and (instance? PGPSecretKey key) (.isSigningKey key)))

(defn- key-encryption? [key]
  (and (instance? PGPPublicKey key) (.isEncryptionKey key)))

(defn- key-master? [& keys]
  (empty? (filter false? (map #(.isMasterKey %) keys))))

; Generate a minimal keyring suitable for signing and encryption. The function returns a two-element vector where the first element is a public portion of the generated keyring and the second is a full (secret) keyring. Parameters: 'userid' is a String identifying the keyring owner; 'password' is a sequence of Character's for a private keys PBE protection. Optional named parameters: 'random' is an object of type java.util.Random, defaults to a new java.security.SecureRandom; 'date' is an object of type java.util.Date representing a keyring creation timestamp, defaults to the current time; both 'signing' and 'encryption' parameters are two-element vectors each specifying the desired algorithm (the first element) and strength (the second element) of signing and encryption keypairs respectively, defaults are ["DSA" 2048] for signing and ["RSA-E" 2048] for encryption, 'encryption' may be nil for no encryption keypair generation; the private key PBE protection will be performed with a 'cipher' algorithm, defaults to "AES256"; the keyring will become obsoleted in 'expire' seconds after the 'date' timestamp, defaults to 0 which means no expiration.
(defn gen-keyring [userid password & 
                   {:keys [random date signing encryption cipher expire] 
                    :or {random (new java.security.SecureRandom),
                         date (new Date),
                         signing ["DSA" 2048],
                         encryption ["RSA-E" 2048],
                         cipher "AES256",
                         expire 0}}]
  (check (sequential? password))
  (let [skp (condp = (pkat-from-str (first signing)) 
              PublicKeyAlgorithmTags/DSA
              (new BcPGPKeyPair PublicKeyAlgorithmTags/DSA 
                (gen-dsa-kp random (second signing)) date),
              PublicKeyAlgorithmTags/RSA_SIGN
              (new BcPGPKeyPair PublicKeyAlgorithmTags/RSA_SIGN 
                (gen-rsa-kp random (second signing)) date)),
        skeb (new BcPBESecretKeyEncryptorBuilder (skat-from-str cipher))]
    (.setSecureRandom skeb random)
    (let [ske (.build skeb (char-array password)),
          dc (.get (new BcPGPDigestCalculatorProvider) 
               HashAlgorithmTags/SHA1),
          csb (new BcPGPContentSignerBuilder 
                (.getAlgorithm (.getPublicKey skp)) HashAlgorithmTags/SHA256)]
      (.setSecureRandom csb random)
      (let [sss (gen-ssv-std date (.getKeyID skp) expire),
            krg (new PGPKeyRingGenerator PGPSignature/POSITIVE_CERTIFICATION 
                  skp userid dc sss nil csb ske)]
        (when encryption
          (let [ekp (condp = (pkat-from-str (first encryption)) 
                      PublicKeyAlgorithmTags/RSA_ENCRYPT
                      (new BcPGPKeyPair PublicKeyAlgorithmTags/RSA_ENCRYPT 
                        (gen-rsa-kp random (second encryption)) date),
                      PublicKeyAlgorithmTags/ELGAMAL_ENCRYPT
                      (new BcPGPKeyPair PublicKeyAlgorithmTags/ELGAMAL_ENCRYPT 
                        (gen-elg-kp random (second encryption)) date)),
                ess (gen-ssv date (.getKeyID skp), 
                      :expire expire, :flags :encrypt)]
            (.addSubKey krg ekp ess nil)))
        [(.generatePublicKeyRing krg) (.generateSecretKeyRing krg)]))))

; Adds a new certification to a keyring. A certification binds keys of a keyring to a particular user identifier. A keyring generated by the 'gen-keyring' API already contains a self-signed certificate. Parameters: 'ringpair' is a two-element collection of a public portion of the keyring to be certified and the full (secret) keyring itself; 'userid' is a user String identifier that will be bound to the 'ringpair' keyring by the newly generated certificate; 'signer' is a secret keyring that will be used as a certificate issuer (self-signing is allowed, i.e. 'signer' could be the same object as the second element of the 'ringpair'); 'password' is a sequence of Character's for the purpose of private signing key extraction from the 'signer'. Optional named parameters: 'random' is an object of type java.util.Random, defaults to a new java.security.SecureRandom; 'date' is an object of type java.util.Date representing a certification creation timestamp, defaults to the current time; when self-signing, the certification will obsolete the keyring in 'expire' seconds after the 'date' timestamp, defaults to 0 which means no expiration. The function returns a new two-element ringpair collection with the certification added to both public and secret keyring objects.
(defn keyring-certify [[public secret :as ringpair] userid signer password &
                       {:keys [random date expire] 
                        :or {random (new java.security.SecureRandom),
                             date (new Date),
                             expire 0}}]
  (check (sequential? password))
  (let [pubk (.getPublicKey public),
        seck (.getSecretKey secret),
        sigk (.getSecretKey signer),
        selfsigning (key-collide? sigk seck)]
    (check (and (key-master? pubk seck sigk) 
             (key-pair? pubk seck) (key-signing? sigk)))
    (let [csb (new BcPGPContentSignerBuilder
                (.getAlgorithm pubk) HashAlgorithmTags/SHA256)]
      (.setSecureRandom csb random)
      (let [sg (new PGPSignatureGenerator csb),
            skdb (new BcPBESecretKeyDecryptorBuilder 
                   (new BcPGPDigestCalculatorProvider)),
            ssv (if selfsigning 
                  (gen-ssv-std date (.getKeyID sigk) expire) 
                  (gen-ssv date (.getKeyID sigk)))]
        (.init sg (if selfsigning 
                    PGPSignature/POSITIVE_CERTIFICATION
                    PGPSignature/DEFAULT_CERTIFICATION)
          (.extractPrivateKey sigk (.build skdb (char-array password))))
        (.setHashedSubpackets sg ssv)
        (let [sig (.generateCertification sg userid pubk),
              cpubk (PGPPublicKey/addCertification pubk userid sig),
              cpublic (PGPPublicKeyRing/insertPublicKey public cpubk)]
          [cpublic (PGPSecretKeyRing/replacePublicKeys secret cpublic)])))))

; Adds a new self-signed revocation to a keyring. A revoked keyring should no longer be used for signing or encryption. Parameters: 'ringpair' is a two-element collection of a public portion of the keyring to be revoked and the full (secret) keyring itself; 'password' is a sequence of Character's for the purpose of private signing key extraction from the secret part of the 'ringpair'. Optional named parameters: 'random' is an object of type java.util.Random, defaults to a new java.security.SecureRandom; 'date' is an object of type java.util.Date representing a revocation creation timestamp, defaults to the current time. The function returns a new two-element ringpair collection with the revocation added to both public and secret keyring objects.
(defn keyring-revoke [[public secret :as ringpair] password &
                      {:keys [random date] 
                       :or {random (new java.security.SecureRandom),
                            date (new Date)}}]
  (check (sequential? password))
  (let [pubk (.getPublicKey public),
        seck (.getSecretKey secret)]
    (check (and (key-master? pubk seck) 
             (key-pair? pubk seck) (key-signing? seck)))
    (let [csb (new BcPGPContentSignerBuilder
                (.getAlgorithm pubk) HashAlgorithmTags/SHA256)]
      (.setSecureRandom csb random)
      (let [sg (new PGPSignatureGenerator csb),
            skdb (new BcPBESecretKeyDecryptorBuilder 
                   (new BcPGPDigestCalculatorProvider)),
            ssv (gen-ssv date (.getKeyID pubk), :revocation true)]
        (.init sg PGPSignature/KEY_REVOCATION
          (.extractPrivateKey seck (.build skdb (char-array password))))
        (.setHashedSubpackets sg ssv)
        (let [sig (.generateCertification sg pubk),
              cpubk (PGPPublicKey/addCertification pubk sig),
              cpublic (PGPPublicKeyRing/insertPublicKey public cpubk)]
          [cpublic (PGPSecretKeyRing/replacePublicKeys secret cpublic)])))))

;-------------------------------------------------------------------------------

(defn -main []
  (println (ns-name ((meta #'library-version) :ns)) (library-version)))

;-------------------------------------------------------------------------------
